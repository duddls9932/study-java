study-java

A_intro

JAVA - 프로그래밍 언어
	프로그래밍 언어는 개발자와 운영체제가 소통하기 위한 언어이다.

소스코드
	개발자와 운영체제가 소통할 것을 글로 작성해 놓은 것.

소스파일(.java)
	소스코드를 작성해 놓은 파일
	
컴파일
	사람의 언어를 컴퓨터 언어로 바꿔주는 작업.

컴파일러
	컴파일 해주는 프로그램 혹은 명령어
	컴파일러는 위에서 아래로 좌에서 우로 번역한다.

프로그램
	소스코드로 잘 짜여진 틀.

콘솔
	개발자와 운영체제가 소통한 결과를 보여주는 창.

---------------------------------------------------------------------------------------------------------------------------
▶ 일반 프로그램
	프로그램
	OS(운영체계 하드웨어에 전기신호를 적절히 흘려주는 역할)
	하드웨어

	이식성이 좋지 않다.
	하드웨어에 직접 접근할 수 있다.

▶ JAVA 프로그램
	JAVA 프로그램
	JVM
	OS(운영체계 하드웨어에 전기신호를 적절히 흘려주는 역할)
	하드웨어

	이식성이 좋다.
	하드웨어에 직접 접근하기 어렵다.
---------------------------------------------------------------------------------------------------------------------------
JVM(Java Virtual Machine)
	JAVA 프로그램을 실행해 줌.

JRE(Java Runtime Environment)
	JVM을 생성하며, 실행할 대 필요한 라이브러리 파일들을 가지고 있다.

JDK(Java Development Kit)
	컴파일 명령어와 실행 명령어를 담고 있다.
	JRE 외에 개발에 필요한 도구들을 가지고 있다.

---------------------------------------------------------------------------------------------------------------------------
JDK 설치
	https://drive.google.com/file/d/1bsLuMXWQ-yg50m4SNToucnhEBMLSg6He/view?usp=drive_link

	※ 환경변수
	설치된 프로그램을 CLI 환경에서 명령어처럼 사용할 때에는,
	해당 경로에서 실행할 수 있다.
	하지만 매번 해당 경로로 들어가서 실행하는 것이 불편하기 때문에
	어디서든지 실행할 수 있도록 환경 변수에 설정할 수 있다.
	설치된 프로그램의 경로를 Path에 등록해주면, 
	이를 통해 해당 명령어를 어디서든지 사용할 수 있게 된다.

IDE(통합 개발 환경) 설치
	- 이클립스(무료, 정부 표준)
		https://drive.google.com/file/d/18qYUbfdkXWrX0hbSnvFOuihh9MXI_k7j/view?usp=drive_link

	- 인텔리제이(유료, 다양한 기능)
---------------------------------------------------------------------------------------------------------------------------
기본 구조
	프로젝트
		패키지(앞글자 소문자)
			클래스(앞글자 대문자)
				메소드(이름 뒤에 소괄호)
					소스코드

---------------------------------------------------------------------------------------------------------------------------
B_print


출력 메소드
1.print(): 마지막에 자동으로 줄바꿈되지 않고 아래문장과 이어서 출력된다.
2.println(): 마지막에 자동으로 줄바꿈된다.
3.printf():서식 문자를 사용하여 출력할 수 있으며, 자동으로 줄바꿈되지 않는다.

출력 메소드를 사용하는 이유
	오류를 구체화하기 위해 개발자가 사용하는 도구이다.

	A코드
	B코드
	C코드
	D코드

	오류 발생시 어떤 라인에서 발생했는지 알 수 없다.

  	A 코드
  	System.out.println("A")
  	B 코드
  	System.out.println("B")
  	C 코드
  	System.out.println("C")
  	D 코드
  	System.out.println("D")

  	"C"가 콘솔에 출력되었다면, 위에서 아래로 번역되기 때문에 D 코드에 문제가 발생한 것으로 판단된다
   ---------------------------------------------------------------------------------------------------------------------------
   C_variable
	
	변수
	변수는 저장공간이다.


	x	=	10
        저장공간의   대입        값(상수)
            이름	연산자

자료형(type)
	자료형은 저장공간의 종류이다.
	
	자료형	type	byte	       값
	
	정수형     byte	1             1,4,100,-120...
		short	2          123,9,150,-55...
		int	4      -2147483648~2147483648
		long	8     30L,8L,-154616978L,.....
	실수형    float       4      3.12F,2.59F,-123.5140F,2.0F
	            double    8      3.12,2.59,-123.5140,2.0	
	문자형    char       2          'a','b','3',.....
	문자열   String     ???    "abc","0.0","123.3213","A","안녕",....     

변수의 선언
	자료의 변수명= 초기값 <초기화 
	
	예)
	int x=10;
	x라는 이름의 저장공간이 int형으로 할당(allocation)되고 그 안에 10이 들어간다

주소

	int x = 10;
	x라는 이름의 저장공간이 int형으로 RAM에 할당되면, 고유한 값인 주소값이 부여된다
	계속 실행되거나 종료되는 프로그램이 있기 때문에, 주소가 이동될 수는 있으나 중복은없다

변수의 사용
	변수는 사용한 부분 통채로를 반드시 값을 본다.
	
	int data =10;   //저장공간
	data = 20      // 저장공간
	data +9        // 값
	data = data+2     //
변수 선언시 주의사항  
	1.같은 이름의 변수로 선언할 수 없다.  
	2.초기화를 해준다
		정수:0
		실수:0.0
		문자:' '
		문자열 "",null  
	3.되도록 선언부에 한꺼번에 선언한다.(영역 상단)
변수를 사용하는이유  
	1. 반복되는 값을 쉽게 관리하기 위해서  
	2.의미없는 값을 하나의 정보로 만들기 위해서 (자료 구조)  
 
 ---------------------------------------------------------------------------------------------------------------------------
 D_casting   
 형변환  
	-자동 형변환  
		정수+정수=정수  
		정수+실수=실수  
		정수+문자=정수  

	-강제 형변환(Casting)  
		(자료형)값;  
		(double)3== 3.0  

문자열 형변환  
	1. 다른 자료형을 문자열로
		문자열과 다른 일반 자료형을 연결하면 결과는 문자열이 된다.  
	2. 문자열을 다른 자료형으로	
		일반 자료형은 일반 자료형끼리만 형변환이 가능하다
		문자열 타입은 클래스 타입이므로 일반 자료형의 클래스 타입의 도움을 받아야한다.  

		InInteger.parsInt("")>> 전달한 문자열에서 변환(추출)된 정수
		Doubleparse.parsintDouble("")>> 전달한 문자열에서 변환(추출)된 정수
  ---------------------------------------------------------------------------------------------------------------------------  
  E_constant  

  상수  
	항상 그대로인 수  
	값을 변경할 수 없도록 한다.  
	
	final 자료형 상수명 = 값;  

상수를 사용하는 이유  
	값에 의미부여를 하기 위해서 

---------------------------------------------------------------------------------------------------------------------------  
F_input  
입력  
	커서가 깜빡이고 있는 상태를 입력 상태라고 한다.  
	입력하기 전에 출력을 통해 어떤 값을 입력해야 할지 사용자에게 알려주어야 한다  

입력 클래스  
	Scanner sc = new Scanner(System.in)  
	-------  ---    -------------------------  
	자료형 변수명            값  
입력 메소드  
	next() 사용자가 입력한 문자의값  
		-사용자가 입력한 값 중 공백 또는 줄바꿈 문자(엔터)를 구분점으로 각문자열을 분리한다.	  
		-두번째 문자열은 두 번째  next ()에 담긴다.  
	nextLine() 사용자가 입력한 문자열 값  
		-공백 문자도 값으로 취급하기 때문에 그대로 입력받는다.  

---------------------------------------------------------------------------------------------------------------------------  
G_poer

연산자
	기능이 있는 특수문자

연산자의 우선순위
	하나의 식에 여러 종류의 연산자가 사용될 경우
	어떤 순서로 연산되는지를 알아보자.

	최우선 연산자
	단항 연산자
	산술 연산자
	쉬프트 연산자
	관계 연산자
	논리 연산자
	삼항 연산자
	대입 연산자

결합성
	하나의 식에 동일한 연산자가 여러 개 사용되면 알맞은 방향으로 결합되어 연산되는 성질
논리형(boolean)  
	참: true  
	거짓: false  

	boolean check = true;  
	boolean check = 10 > 11;  

	초기값은 false이다.  

조건식  
	결과가 참 또는 거짓, 둘 중 하나가 나오는 식.  
	항상 조건식은 값으로 봐야한다!!  

	관계 연산자  
		==	같다  
		!=	같지 않다  
		>, <	초과, 미만  
		>=, <=	이상, 이하	  

	논리 연산자  
		&& (AND), A && B		두 조건식 모두 참이면 참  
		|| (OR), A || B		둘 중 하나라도 참이면 참  

	단항 연산자  
		! (NOT), !A		참을 거짓으로, 거짓을 참으로 변경  

	삼항 연산자  
		? :	조건식 ? 참 : 거짓, 조건식이 참이면 참, 거짓이면 거짓  
		예) int result = (10 > 11 ? 10 : 11) + 3;  


대입 연산자 (복합 대입 연산자, 누적 연산자)  
	+=, -=, *=, /=, ...  

	int money = 10000;  
	// money = money - 1000  
	money -= 1000  
	System.out.println(money)   

	int data = 10;  
	// data = data + 1;  
	// data += 1;  
	data++;  
 
대입연산자 복합 대입 연산자,누적연산자   
	int money=10000;  
	money-1000 <9000의값일뿐 머니는 그대로 10000   
            money=money-1000 으로해야 9000이 출력됨   
	money -=1000 == money=money-1000  
	syso money 출력시 10000나옴   
 
 ---------------------------------------------------------------------------------------------------------------------------
 H_control_statement
 제어문
	컨파일러의 흐름을 제어할 수 있는 문법.  
   ▶ 조건문
      ▷if문
         if(조건식){
            실행할 문장;
         }
제어문  
   컴파일러의 흐름을 제어할 수 있는 문법.  

   ▶ 조건문
      ▷if문
         if(조건식){
            실행할 문장;
         }
         (1)  위의 조건식 결과와 상관 없이 무조건 검사
         if(조건식){
            실행할 문장;
         }
         if(조건식){
            실행할 문장;
         }
         ...

         if(조건식){
            실행할 문장;
         }
         (2) 위의 조건식이 false여야 검사, true라면 검사하지 않는다.
         else if(조건식){
            실행할 문장;
         }
         else if(조건식){
            실행할 문장;
         }
         ...
         else {
            실행할 문장;
         }
 
      ▷switch문  
         switch(값) {  
         case 값1:  
            실행할 문장;  
            break;  
         case 값2:  
            실행할 문장;  
            break;  
      
         ...  
         default:  
            실행할 문장;  
            break;  
         }  


   ※ 삼항 연산자, if문, switch문의 비교  
      삼항 연산자: 조건식을 1개만 사용할 때  
      if문: 조건식에 비교(>, <, >=, <=) 연산자를 사용하거나, 여러 개의 조건식을 논리 연산자로 연결할 때  
      switch문: 하나의 변수에 여러 경우의 값이 담길 수 있고, 각 값이 같은지 비교할 때  


      ▶ 반복문  
      ▷ for문  
         int i = 0;    i < 10;   i ++  
         for(초기식; 조건식; 증감식) {  
            실행할 문장;  
         }  

         1. 초기식  
         -------------------
         2. 조건식(true)  
         3. 실행할 문장  
         4. 증감식  

         5. 조건식(true)  
         6. 실행할 문장  
         7. 증감식  

         8. 조건식(false)  
         9. 종료  

      ▷ while문  
		while(조건식){  
			실행할문장;  
		}  
      ▷ do ~ while문  
		do{ 실행할 문장;  
}  
		while(조건식);  
   ※ for문, while문, do~while문  
      for문: 몇 번 반복할지 알 때  
      while문: 몇 번 반복할지 모를 때  
      do~while문: 무조건 처음 한 번은 실행해야 할 때  
	
기타제어문  
	break: 즉시 해당 중괄호 영역을 탈출한다.  
		-if문안에서 사용시 if문을 탈출하는 게 아니라 감싸고 있는 중괄호 영역을 탈출한다  


	continue: 즉시 다음 반복으로 넘어간다.  
		-아래의 코드를 실행하지 않기 위해서 사용한다.  

 ---------------------------------------------------------------------------------------------------------------------------

 I_array

 배열: 저장공간의 나열  
   1.  
      변수를 여러 개 선언하면 이름도 여러 개 생긴다. 이 때 각 저장공간을 관리하기  
      불편하다. 따라서 n칸 배열을 한 번만 선언하면 저장공간도 n개 생기고,  
      이름도 한 개이기 때문에 관리하기 편하다.  
   2.  
      규칙성이 없는 값에 규칙성을 부여하기 위해서  

배열의 선언  
   자료형[] 배열명 = {값1, 값2, ...}; // 어떤 값을 넣을지 알 때 사용한다.  
   자료형[] 배열명 = new 자료형[칸수] // 어떤 값을 넣을지는 모르나, 몇 칸 만들지는 알 때 사용한다.  
   자료형[] 배열명 = null; // 어떤 값을 넣을지도 모르고, 몇 칸 만들지도 모를 때 사용한다.  

   ※ new: Heap 메모리에 할당, 초기값으로 자동 초기화  
   ※ null: 주소의 초기값, 어떤 주소를 넣을지 모를 때 작성하는 값  
   ※ 자바에서 배열은 항상 Heap(동적 메모리에)에 할당되기 때문에 메모리 상으로는 동적 배열만 존재한다.  

배열의 구조  
   int[] arData = {3, 5, 1, 2, 8};  

   arData라는 이름의 저장공간 한 개가 만들어지며, 여기에는 한 개의 값만 담을 수 있다.  
   5개의 값을 담기 위해서는 5칸이 필요하며, 이는 Heap 메모리에 할당된다.  
   5칸의 저장공간 중, 첫 번째 저장공간의 주소값이 arData 저장공간으로 들어가며,  
   다음 주소에 접근하기 위해서는 + n을 한다.  
   예를 들어 arData + 2는 1이라는 값이 담긴 주소값이 되며,  
   *(arData + 2)는 해당 주소에 가서 읽어온 1이라는 값이 된다.  
   JAVA에서는 직접 주소에 접근하는 연산자가 없기 때문에 위와 같은 식을 []로 치환하여 사용한다.  
   즉, arData[2]는 1이란 값이 된다. 방 번호는 index라고 부르며, 배열은 시작주소를 가지고 있기 때문에
   인덱스 번호는 항상 0부터 시작된다.  

length  
   배열을 선언하면 length라는 상수가 선언되고, 해당 배열의 길이가 담긴다.  
   배열명.length로 사용하게 된다.  

배열의 사용  
   int[] arData = new int[5];   // 저장공간  
   arData[0] = 120;      // 저장공간  
   arData[0] + 9      // 값  
   System.out.println(arData)   // 주소값  
   arData[2] = arData[0] + arData[1] // 저장공간, 값, 값  
   System.out.println(arData[5]);   // 오류  
   
---------------------------------------------------------------------------------------------------------------------------  
J_method

메소드  
   이름뒤에
   ()소
   {}중
   []대
   단, 키워드 뒤에 소괄호는 메소드가 아니다 final, int등이 키워드이다.
   저장공간이다.

   f   (x)    =    2x + 1 => 
    메소드   매개(연결)   리턴값  
   이름   변수        


메소드 선언
   (1)리턴타입 (2)메소드명(자료형 (3)매개변수명, ...{   
      (4)실행할 문장
      (5)return 리턴값;
   }

   (1) 리턴값이 있다면 리턴값의 자료형을 작성하고, 리턴값이 없다면 void를 작성한다.  
   (2) 동사로 작성한다.(연필을 쓴다.)  
   (3) 외부에서 전달받을 값이 있다면, 자료형과 순서에 맞게 선언해준다.  
       생략하면, 외부에서 값을 전달받을 수 없게된다.  
   (4) 생략이 가능하다. 메소드의 기능을 구현하는 로직(코드)을 작성하게 된다.  
   (5) 생략이 가능하다. 리턴값이 있다면, 사용한 부분 통채로를 리턴값으로 봐야한다.  

메소드 선언 순서
   문제) 두 정수의 덧셈 메소드 선언
   
   1.메소드 이름을 생각한다.
      add(){}

   2.매개변수를 생각해라
      add(int number1, number2){}

   3.실행할 문장을 작성한다.
      add(int number1, number2){
         int result = number1 + number2
      }

   4.리턴값을 작성한다.
      add(int number1, number2){
         int result = number1 + number2
         return result;
      }
   5.리턴타입을 결정한다.
      int add(int number1, number2){
         int result = number1 + number2
         return result;
      } 
      

메소드 주의사항  
   0.메소드를 선언은 {}가있다면 {}가없다면 메소드 사용  
   1.메소드를 선언할 때{}가 있으면, 반드시 메소드 밖에서 선언한다.(ctrl + 클릭 하면 어디서 선언했는지 사용가능)  
   2.메소드를 사용할 때{}가 없으면, 반드시 메소드 안에서 사용한다.  

메소드를 사용하는 이유  
   1.재사용(특정성을 부여해서는 안된다.)  
   2.소스코드 간결화  

다형성(Polymorphism) 이림이 1개인데 형태가 다양함  
1. 오버로딩(Overloading) 불러오기   
매체변수의 개수 또는 자료형이 다르면 동일한 이름의 메소드로 선언할수있다.  
2.오버 라이딩 (Overriding,무시하기,재정의)  
부모 필드에서 선언한 메소드를 자식 필드에서 수정하고자 할떄 재정의한다.  
같은 이름의 메소드로 선언하면, 자식 객체로 접근 했을때 가까운 곳에서 찾기 때문에  
자식 필드(this)에서 재정의된 메소드가 사용된다  
만약 재정의된 메소드 안에서 부모의 기능을 그대로 사용하고싶다면  
super로 접근해서 사용할 수있다  



---------------------------------------------------------------------------------------------------------------------------
K_class
클래스 	
	공통 요소를 한 번만 선언해 놓고 가져다 사용만 하도록 설계한다 .

	1. 타입이다.
		클래스 안에 선언된 변수와 메소드를 사용하고 싶다면,
		해당 클래스 타입으로 변수를 선언해야 한다.

	2 주어이다.
		Monkey.eat("바나나")
		원숭이가 먹는다 바나나를 
		주어 , 동사 ,명사
		항상 클래스로 시작하기 때문에
		클래스는 앞글자를 대문자로 작성해야 한다.

클래스 선언
	class 클래스명{
		필드(변수,메소드)
	}
클래스 필드 사용
	1. 객체화(instance): 객체 (instance variable)을 만드는 작업, 추상적인 개념을 구체화시키는 작업.
		클래스명 객체명=new 클래스명 ();
		※.(마침표):하위 연산자, 멤버변수 접근 연산자, 닷 연산자,점연산자
		주소값 뒤에서만 사용하며,해당 주소를 참조하는 명령어이다.

	2. static 모든 객체가 공유해야하는 필드일 경우 사용한다.
		클래스 하나 당 한개만 생기기 때문에 객체로 접근하지않고 클래스로 접근한다.

생성자
	클래스 이름 뒤에 소괄호가 있는 형태 메소드와 기능이 같지만 메소드라고 부르지않는다
	생성자는 리턴이라는 기능이 존재하지 않기 대문이다.

	1. 해당 클래스의 필드를 메모리에 할당한 후 부여된 주소값을 가져온다.
	2.초기화

기본생성자
	매개변수가 없는 생성자이며,클래스 선언시 자동으로 선언된다.
	사용자가 직접 생성자를 선언하게 되면 기본 생성자는 없어진다.

this
	필드에 접근한 객체가 누군지 알아야 해당 필드에 접근할수있따.
	이 때 접근한 객체가 가지고있는 필드 주소값이 this라는 변수에 자동으로 담긴다.

변수의 종류
	전역 변수
		클래스의 필드로서, 메소드 밖에서 선언하며 클래스 내에 모든 메소드에서 접근 가능하다.
		생성자를 통해 메모리에 할당되고, 객체마다 별도로 존재한다.
		즉,전역변수는 클래스의 구성요소로 선언된다.
	지역 변수
		메소드 내부 또는{}내부에서 선언되는 변수로서,
		선언된 영역 내에서만 사용할 수 있다. 해당 영역이 종료되면 사라진다
		초기화를 하지 않으면 사용할 수 없기때문에 반드시 직접 초기화해준다
	정적 변수(static 변수)
		클래스 변수라고도 하며,static키워드를 사용해준다.
		프로그램 실행시 가장 먼저 메모리에 할당되고, 단 한번만 할당된다.
		모든 객체가 공유하기 때문에 객체 생성없이 클래스로 접근할 수 있다.
		



---------------------------------------------------------------------------------------------------------------------------
L_inheritance

상속(inheritance)
   1. 기존에 선언된 클래스의 필드를 새롭게 만들 클래스의 필드로 사용하고자 할 때
   2. 여러 클래스 선언 시 필드가 겹치면, 부모 클래스를 먼저 선언하고
      공통 필드를 묶어서 각 자식 클래스들에게 상속해준다.

상속 문법
   class A {
      A 필드
   }

   class B extends A {
      A, B 필드
   }

   A: 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
   B: 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

super(): 부모 생성자
   자식 클래스 타입의 객체는 부모 필드에 접근할 수 있다.
   하지만 자식 생성자만 호출하기 때문에, 자식 필드만 메모리에 할당된다.
   그렇기 때문에 B 타입의 객체로 A 필드(부모 필드)에 접근할 수 없어야 정상이다.
   사실 자식 생성자에서 항상 부모 생성자를 호출하기 때문에
   자식 생성자 호출 시 부모와 자식 필드 모두 메모리에 할당된다.
   이 때, 부모 생성자를 호출하는 방법은 super()을 사용하는 것이다.
   만약, super()를 작성하지 않더라도 컴파일러가 자동으로 작성해준다.
   반드시 코드 맨 첫 줄에 작성하고 시작해야 한다.


접근 권환 제어자 (접근자)
	1default 다른 패키지에서 접근불가
	2public 모든 곳에서 접근 가능. 만약 클래스 앞에 붙인다면 해당 파일의 메인 클래스를 의미한다
	3protected 다른 패키지에서 접근불가 자식은 접근가능
	4private 다른 클래스에서 접근불가

	※ private을 이해해보자
		주로 메소드로 접근하라는의미로 사용된다
		왜냐하면 화면에서 해당 필드를 접근하는 방법은 오로지 메소드뿐이다
		private 접근자를 붙이고 외부에서 접근할 수 있도록 public 메소드를 만들어 놓는것이 모델링 컨벤션이다.
		이 때 public 메소드는 2가지이고 각각 getter , setter라고 부른다.
		이제부터는 정보를 담아놓을 클래스를 선언할때 각 변수앞에private을 붙여주고
		이를 접근할 수 있도록 public 접근자로 getter,setter를 선언하기로 약속한다.


---------------------------------------------------------------------------------------------------------------------------
M_casting

※ 모든 자식은 부모타입이다.

Casting
	1.up casting
		자식 값을 부모 타입으로 형변환.
		자식에서 구현한 필드는 다른 곳에 위치하고
		구현된 부모 필드만 들어간다.

	2.down casting
		부모 타입에 자식값을 담아놓은 up casting된 객체는
		다시 자식타입에 담을 수 있다.
		이 때 분리되었던 자식 필드가 다시 붙어서
		자식 타입에 들어간다.

	※ 부모 값을 자식 타입으로 형변환시 오류 발생

Casting을 잘 사용하는 방법
	모든 자식들을 하나의 타입으로 묶을 때 up casting을 진행한다.
	전달받은 자식 객체가 어떤 타입인지 검사한 뒤
	해당 타입으로 down casting을 진행한다.
	즉 묶어서 하나의 타입으로 받고 다시 원래 타입으로 복구하자!


---------------------------------------------------------------------------------------------------------------------------
O_abstract

추상 클래스
	필드 안에 구현이 안된 메소드가 선언되어 있는 클래스를 추상 클래스라고 한다.
	이 때 구현되지 않은 메소드를 추상 메소드라고 부른다
	즉, 추상 클래스에 추상 메소드를 선언할 수 있다.
	반드시 재정의를 통해 구현을 해야 메모리에 할당되기 때문에 "강제성"을 위해 사용한다

추상 클래스 선언
	abstract class 클래스명{
		abstract  리턴 타입 메소드명(매개변수,....);

		//일반 메소드도 선언 가능
		리턴 타입 메소드명(매개변수,....);{
	}

}

인터페이스(틀)
	추상 클래스를 고도화시킨 문법,상수와 추상 메소드만 존재한다.
	구현은 지정한 클래스에서 진행하고 인터페이스를 다른클래스에 지정할때는
	inplements 키워드를 사용한다.
	
추상 클래스와 인터페이스 간의 관계
	인터페이스를 클래스에 바로 지정하면 모든 메소드에 강제성이 부여되기 때문에 전부다 구현해야한다.
	하지만 일반적인 상황에서는 필요한 메소드를 골라서 재정의한다
	따라서 인터페이스를 직접 지정하지않고 다른클래스에 지정 후 구현해놓는다면
	이 때 중간에서 강제성을 없애주는 클래스를 추상 클래스로 선언하기로 하며,
	추상 클래스 이름 뒤에는 Adapter를 붙여서 목적을 알려준다

인터페이스의 특징 
	1. 인터페이스도 자료형이다 인터페이스를 구현한 클래스는 모두 인터페이스 자료형이다.
	2. 인터페이스끼리 필드를 주고 받을 때에는 extends키워드를 사용한다.
	3. default 메소드를 사용하면 인터페이스 내부에서 일반메소드 선언이 가능하다.(JDK 8버전 부터)

내부 클래스
	어떤 영역 안에 클래스가 선언되면 내부클래스라고 한다.


익명클래스(Anomymous Inner Class)
	이름이 없는클래스  이며 구현되지 않은 필드를 구현하기 위해서 일회성으로 생성하는 클래스




---------------------------------------------------------------------------------------------------------------------------
P_interface

인터페이스(틀)
	추상 클래스를 고도화시킨 문법, 상수와 추상 메소드만 존재한다.
	구현은 지정한 클래스에서 진행하고, 인터페이스를 다른 클래스에 지정할 때에는
	implements 키워드를 사용한다.
	
추상 클래스와 인터페이스 간의 관계
	인터페이스를 클래스에 바로 지정하면 모든 메소드에 강제성이 부여되기 때문에 전부 다 구현해야 한다.
	하지만 일반적인 상황에서는 필요한 메소드를 골라서 재정의한다.
	따라서 인터페이스를 직접 지정하지 않고 다른 클래스에 지정 후 구현해 놓는다면,
	강제성이 소멸되고 이로 인해 골라서 재정의 할 수 있게 된다.
	이 때 중간에서 강제성을 없애주는 클래스를 추상 클래스로 선언하기로 하며,
	추상 클래스 이름 뒤에는 Adapter를 붙여서 목적을 알려준다.


인터페이스의 특징
	1. 인터페이스도 자료형(타입)이다. 인터페이스를 구현한 클래스는 모두 인터페이스 자료형이다.
	2. 인터페이스끼리 필드를 주고 받을 때에는 extends 키워드를 사용한다.
	3. default 메소드를 사용하면, 인터페이스 내부에서 일반 메소드 선언이 가능하다(JDK8버전 부터) 


---------------------------------------------------------------------------------------------------------------------------
Q_anonymous

내부 클래스(Inner Class)
	어떤 영역 안에 클래스가 선언되면 내부 클래스라고 한다.

익명 클래스(Anonymous Inner Class)
	이름이 없는 클래스이며, 구현되지 않은 필드를 구현하기 위해서 일회성으로 생성되는 클래스이다.


---------------------------------------------------------------------------------------------------------------------------

R_lambda

함수형 인터페이스  functional Interface
	인터페이스 중 추상 메소드를 하나만 가지고 있는 인터페이스를 함수형 인터페이스라고한다.
	이 때 @Functionallnterface를 인터페이스 위에 작성하여 단 하나의 추상 메소드만 선언하도록 제안한다.


람다식
	 함수형 인터페이스에서 한 개의 추상 메소드만 존재하기 때문에 구현시 메소드 이름이 딱히 필요가 없다
	람다식은 이름이 없는 메소드로서 값처럼 사용이 가능하고 당연히 매게변수로도 전달이 가능하다
	따라서 람다식 익명 메소드(Anorymous).라고도 부른다

람다식 문법
	1.(매개변수 형식 나열,...) > 리턴값;
	2.(매개변수 형식 나열,...)>{실행할 문장;리턴값}
	3.매개변수 -> 리턴값
	4.매개변수 -> {실행할 문장; return 리턴값;);
	5.참조형 
		생성자 참조
			클래스명:new
		메소드 참조
			static:	클래스명::메소드명
			일반:	 객체명:메소드명

---------------------------------------------------------------------------------------------------------------------------
S_exception

컴파일 순서
   1. 디버그: 오류 검사
   2. 빌드: 프로그램 생성
   3. 링크: 생성된 프로그램까지의 경로를 저장한다.
   4. 실행

예외 처리
   1. 컴파일 오류: 빨간줄, 문법오류
   2. 빌드 오류: 실행하자마자 오류
   3. 런타임 오류: 잘 실행되다가 갑자기 오류, 사용자의 입력 및 외부 요인에 의한 오류

   런타임 오류는 제어문으로 막을 수 없는 경우가 생긴다. 이 때, 예외 처리 문법으로 해결할 수 있다.
   
예외 처리 문법
   try {
      오류가 발생할 수 있는 문장;

   } catch (예외 이름 객체명) {
      오류 발생 시 실행할 문장;

   } catch (예외 이름 객체명) {
      오류 발생 시 실행할 문장;

   } 
   ...

   } finally {

   }

예외 발생
   직접 예외를 발생시키기 위해서는 예외 던지기를 사용해야 하며, 이 때 생성자 호출 전 throw 키워드를 사용한다.
   예) throw new BadWordException();

사용자 정의 예외
   기본적으로 제공되는 예외가 아닌 특정 상황에서 직접 예외를 만들 수 있어야 한다.
   Exception 혹은 RuntimeException을 상속받아서 예외 클래스를 선언해야 한다.
   1. Exception은 컴파일 오류가 발생하기 때문에 예외처리를 강제로 해야 하고
   2. RuntimeException은 컴파일 오류가 발생하지 않기 때문에 예외처리를 선택할 수 있다.



---------------------------------------------------------------------------------------------------------------------------
T_api

API(Application Programming Interface)
	개발에 필요한 라이브러리들의 집합
	선배 개발자들이 만들어 놓은 소스코드의 집합.
	-내부 API
		JDK 설치 시 제공해주는 기본API
	-외부 API
		사설 업체에서 개발한 패키지 및 클랫들을 의미한다.
		보통 JAR파일로 배포하며 자바프로젝트의 build path에 추가해서 사용한다.
		

---------------------------------------------------------------------------------------------------------------------------
U_object

Object 클래스
	최상위 부모 클래스로서 모든 클래스는 자동으로 Object를 상속받는다.

	1.toString()
		항상 개체명을 출력할 때에는 toString()을 붙여서 출력해준다.
		따라서 객체명만 출력 메소드에 전달하더라도 toString()의 문자열 값이 출력된다
		기본적으로 Object에 선언된 toString()은 소속과 필드 주소를 문자열로 리턴해주지만
		실사용에서는 불필요한 정보이기 때문에 재정의 후 필드의 정보를 확인하도록 구현한다
		실무에서는 클래스 선언 시 각 필드의 초기화 여부를 확인하기 위해 toString()을 재정의하여 사용한다
             오브젝트라는 부모클래스의 메소드를 a클래스에서 재정의하여 b에서 사용했을떄 확인하기쉽게 만들어둔것? 


	2.equals()
		주소값을 비교하는 메소드이며 ==과 동일하다.
		Stirng 클래스에서 equlas()를 값 비교로 재정의하여 사용하기 때문에
		문자열 비교는 무조건 equals()로 한다.
		만약 주소 비교가 아닌 원하는 필드를 비교하고자 한다면 반드시 equals()를 재정의해서 사용해야한다 .

		
	3.hashCode()
		자바에서 사용하는 고유한 주소값이다.
		JVM에서 관리하는 중복없는 값으로써  실제 메모리 주소와는 다르다.
		※컬렉션 프레임워크 챕터에서 재정의 목적을 이해하도록한다.
	

---------------------------------------------------------------------------------------------------------------------------
V_collection_framework

알고리즘 
	 어떤 문제가 발생되었을 때 해결할 수 있는 절차 혹은 순서 .
자료구조(저장공간)
	의미없는 데이터를 하나의 정보로 만들어주는 알고리즘들의 집합.
	저장소의 종류에 대해 알아보자!


컬렉션 프레임워크(Collection Framework):자료구조
	많은 데이터를 쉽고 효과적으로 관리할 수 있는 자료구조 클래스들의 집합.


List
	List는 인터페이스이다.

	1.Vector. 용량 관리, 보안성 강화, 처리량 감소
	2.LinkedList  FiLO로 인해 넣을때는 빨라도 원하는 위치의 데이터를 가져오는 것이 상대적으로 느리다.
	3.ArrayList 인덱스로 데이터를 관리한다. 컬렉션 클래스중 실무에서 가장많이 사용되는 클래스이다.
		배열의 특징인 인덱스를 이용하여 값을 저장하고 관리한다.
	
 
	※ 배열과 ArrayList의 차이
		배열은 길이에 제한을 두어야 할 때 사용되고
		ArrayList 몇개의 데이터가 들어올 지 알 수 없을때 사용한다.


Set(집합)
	Set은 인터페이스 이다. List와 마찬가지로 Collection인터페이스를 상속받은 인터페이스이다.

	HashSet
		집합에서 중복되는 원소를 포함할수 없는것처럼
		HastSet이라는 자료구조는 중복되는 값을 무시한다.
		저장된 값들은 인덱스가 없기 때문에 순서가 없다.
		값의 유무 검사에 특화되어있는 자료구조이고 해시코드로 유무검사가 
		진행되기 때문에 속도가 상대적으로 좋다.

	Iterator	
		순서가 없는 객체에 순서를 부여하거나, 순서가 있어도 Iterator 방식의 순서로
		변경 하고자 할때 사용한다.
		이 때 해당 객체에 ineraton()메소드를 붙여주고 이 메소드의 리턴타입은
		Iterator이다.
		hasNext()를 사용하면 다음 값이 있는지 검사하고 next(0를 사용해서 값을 가져올  수 있다.

Map
	Set과 Collection 2개의 자료구조를 하나 합친 자료구조이다.
	List와 Set처럼 Collection을 상속받지 않았고 독립적인 자료구조이다.

	HashMap
		Key와 Value, 한쌍으로 저장되며 검색의 목적을 가지고있다.
		Key에 중복된 값을 넣으면 Value가 최근 값으로 수정되고
		중복되지 않은 값을 넣으면 새롭게 추가된다.
		Value는 중복이 가능하다.



---------------------------------------------------------------------------------------------------------------------------
W_thread

프로그램
   실행이 안된 상태.

프로세스
   실행중인 프로그램.

쓰레드
   프로세스 내의 작업 처리 경로

   -싱글 쓰레드(단일 쓰레드)
      처리 경로를 한 개만 가지고 있기 때문에 직렬적이다.
      한 번에 하나씩 처리하기 때문에 상대적으로 비효율적이지만
      하나의 작업에 문제가 발생하더라도 다른 작업은 시작하지 않았기 때문에
      다른 작업에는 문제가 발생하지 않는다. 따라서 안정성이 보장된다.
      또한 멀티 쓰레드에 비해 설계가 쉽다.

   
   -멀티 쓰레드(다중 쓰레드)
      하나의 프로세스를 동시에 처리하는 것처럼 보이지만 사실은 매우 짧은 단위로 분할해서 차례로 처리한다.
      여러 개의 처리 경로를 가질 수 있도록 하며, 동시 작업이 가능해진다.
      하나의 쓰레드 문제 발생 시, 모든 쓰레드에 문제가 발생하게 되므로 멀티 쓰레드로 설계한다면,
      처리량 증가, 효율성 증가, 생산성 증가의 장점이 있기 때문에 이러한 단점을 감수하고 설계하는 편이다.


멀티 쓰레드 구현 방법
   핵심:run() 메소드를 재정의

   1. Thread 클래스 상속
	run()메소드를 재정의하여 자원을 구성하고
	해당 객체에서 부모(Thread)의start()를 사용하여 스케줄링한다.

   2. Runnable 인터페이스 구현
	run() 메소드를 구현하여 자원을 구성하고
	해당 객체를 Thread 생성자에 전달하여 Thread 객체로 start()를 사용한다
	
	※ extends는 단한번만 사용할 수 있기 때문에 보통 Runnable을 구현하여 멀티 쓰레드 환경을 구축한다.
	 이 때 Runnable은 함수형 인터페이스이기 때문에 run()메소드를 람다로 구현하여 사용할 수도 있다.
동기화(Synchrorized)
	하나의 쓰레드가 자원에 접근 중일 때 다른 쓰레드가 동시에 같은 자원을 접근하지 못하게 막는것.
	자원 공유 시 연산을 건너뛰는 문제가 발생한다. 이를 자원 공유 문제라 부르고,
	동기화를 통해 이 문제를 해결할 수 있다.
동기화 문법
	- 블록
		synchronized(muter){
		-	
	}
	영역 전체에 동기화 걸린다.
	mutex는 문이고, 이 문에 들어오는 쓰레드는 lock 상태에 돌입한다.
	해당 자원을 모두 사용하면(코드 모두 실행 후 ) lock을 해제하고 다음 쓰레드가 들어온다.


	영역 전체에 동기화가 걸린다.
	-키워드
		synchronized
		메소드 리턴 타입 앞에 작성하면, 해당 메소드가 전체 동기화에 걸린다
String
	새로운 문자열 상수를 대입할 때마다 , 동일한 문자열이없다면 Constant pool에 객체가 생성된다.
	만약 + 연산으로 문자열을 반복해서 연결하게 되면 그 만큼의 객체가 생성되기 때문에
	메모리 비용을 많이 발생시킨다

StringBuilder
	하나의 객체를 생성한 뒤 append() 메소드에 연결할 문자열을 전달하는 방식으로 사용한다.
	매번 객체가 생성되지 않고, 하나의 객체만으로 문자열을 연결시키므로
	직접 + 연산자를 사용하는 것보다 메모리 비용을 상당히 감소시킬수 있다 .
	완성된 문자열은 toString()메소드로 확인 할 수 있다.


StringBuffer
	StringBuilder와 마찬가지로 하나의 객체만으로 문자열을 연결시킨다.
	내부적으로 동기화 코드가 포험되어있기 때문에 단일 쓰레드에서는 오히려
	속도를 저하되므로 잘 사용하지않는다.
	하지만 멀티쓰레드 환경에서는 매번 동기화 블록을 감쌀 필요가 없기 때문에 편하고
	StringBuilder(JDK5부터 등장 ) 가없었을 떄 StringBuffer만 존재했으므로
	오래된 코드나 라이브러리들은 여전히 StringBuffer를 사용하고 있을수 있다

---------------------------------------------------------------------------------------------------------------------------
X_file

파일 입출력
	Stream이라는 연결통로를 통해 원본 데이터가 알맞은 인코딩 방식으로 전송된다.
	byte 단위로 입출력되기 때문에 개별처리이며 , 상세 연산이 필요하지 않다면,
	Buffer를 사용한 입출력을 권장한다. Buffer를 사용하면 일괄처리가 가능해진다.

Writer(출력)
	BufferedWriter
		버퍼를사용하는 출력 클래스
	FileWriter
		전달한 경로의 파일을 출력 목적으로 열어준다.	
		전달한 경로에 파일이 없다면 새롭게 만든 후 열어준다.
Reader(입력)
	BufferedReader
		버퍼를 사용하는 입력 클래스
	FileReader
		전달한 경로의 파일을 입력 목적으로 열어준다.
		전달한 경로에 파일이 없다면 FileNotFoundException이 발생한다.

File < 클래스이름
	전달한 경로에 있는 파일의 정보를 담는 타입
	디렉터리 생성, 해당경로의 전체 파일 목록, 파일 삭제 등;

---------------------------------------------------------------------------------------------------------------------------
Y_jdbc

JDBC(Java Database Connectivity)
	Java와 RDB간의 연결을 위한 기술

소프트웨어 디자인 설계 패턴     
MVC 패턴 
	M(Model):
		테이블에서 조회된 결과값 혹은 화면으로부터 
		전달받은 값을 담기위한 
		변수들이 선언된클래스
		-클래스명 뒤에 VO 또는 DTO라는 문자열을 붙여준다.
		-VO(Value Object): 테이블을 보고 그대로 만든 객체, 단일 테이블 조회
		-DTO(Data Transfer Obejct): 화면에 결과를 한 번에 묶어서 전달할 객체 여러테이블 조회

	V(View)
		사용자에게 보여질 화면을 구성하는 부분

	C(Controller)
		JSP 챕터에서 이해할 수 있다
		-Controller에 작성되는 코드가 길어지기 때문에 DBMS SQL문 관련 코드만 따로 분리한다.
		이렇게 분리한 SQL문 관련 코드는 DAO라는 클래스에 분리한다.
		-DAO(Data Access Object): CRUD 기능(메소드)만 모아 놓은 객체.
		-조회 결과는 보통 VO또는 DTO에 담겨서 리턴된다.
