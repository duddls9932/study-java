메소드
   이름뒤에
   ()소
   {}중
   []대
   단, 키워드 뒤에 소괄호는 메소드가 아니다 final, int등이 키워드이다.
   저장공간이다.

   f   (x)    =    2x + 1 => 
    메소드   매개(연결)   리턴값
   이름   변수      


메소드 선언
   (1)리턴타입 (2)메소드명(자료형 (3)매개변수명, ...{   
      (4)실행할 문장
      (5)return 리턴값;
   }

   (1) 리턴값이 있다면 리턴값의 자료형을 작성하고, 리턴값이 없다면 void를 작성한다.
   (2) 동사로 작성한다.(연필을 쓴다.)
   (3) 외부에서 전달받을 값이 있다면, 자료형과 순서에 맞게 선언해준다.
       생략하면, 외부에서 값을 전달받을 수 없게된다.
   (4) 생략이 가능하다. 메소드의 기능을 구현하는 로직(코드)을 작성하게 된다.
   (5) 생략이 가능하다. 리턴값이 있다면, 사용한 부분 통채로를 리턴값으로 봐야한다.

메소드 선언 순서
   문제) 두 정수의 덧셈 메소드 선언
   
   1.메소드 이름을 생각한다.
      add(){}

   2.매개변수를 생각해라
      add(int number1, number2){}

   3.실행할 문장을 작성한다.
      add(int number1, number2){
         int result = number1 + number2
      }

   4.리턴값을 작성한다.
      add(int number1, number2){
         int result = number1 + number2
         return result;
      }
   5.리턴타입을 결정한다.
      int add(int number1, number2){
         int result = number1 + number2
         return result;
      }
      

메소드 주의사항
   0.메소드를 선언은 {}가있다면 {}가없다면 메소드 사용
   1.메소드를 선언할 때{}가 있으면, 반드시 메소드 밖에서 선언한다.(ctrl + 클릭 하면 어디서 선언했는지 사용가능)
   2.메소드를 사용할 때{}가 없으면, 반드시 메소드 안에서 사용한다.

메소드를 사용하는 이유
   1.재사용(특정성을 부여해서는 안된다.)
   2.소스코드 간결화

다형성(Polymorphism) 으림이 1개인데 형태가 다양함
   1. 오버로딩(Overloading) 불러오기 
	매체변수의 개수 또는 자료형이 다르면 동일한 이름의 메소드로 선언할수있다.
   2.오버 라이딩 (Overriding,무시하기,재정의)
	부모 필드에서 선언한 메소드를 자식 필드에서 수정하고자 할떄 재정의한다.
	같은 이름의 메소드로 선언하면, 자식 객체로 접근 했을때 가까운 곳에서 찾기 때문에
	자식 필드(this)에서 재정의된 메소드가 사용된다
	만약 재정의된 메소드 안에서 부모의 기능을 그대로 사용하고싶다면
	super로 접근해서 사용할 수있따
